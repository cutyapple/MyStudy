## 2장 파이썬 코드를 정돈하기 위한 패턴



### 2.1 단언문

#### 단언문이란?

* 어떤 조건을 테스트하는 디버깅 보조 도구.

* 단언 조건이 참이면, 아무 일도 일어나지 않고 프로그램이 정상 실행된다. 그러나 조건이 거짓이라면 AssertinoError 예외가 발생한다.

* ```python
  def apply_discount(product, discount):
      price = int(product['price'] * (1.0 - discount))
      assert 0 <= price <= product['price']
      return price
  
  shoes = {'name': 'Fancy Shoes', 'price': 14900}
  
  print(apply_discount(shoes, 0.25))	# 정상 동작 11175
  print(apply_discount(shoes, 2))		# 할인가는 원가보다 낮고 0원보다 높아야 하므로 assert 예외 발생. -14900
  ```

* 단언 조건을 통하여 잘못된 코드 라인을 알 수 있고, 디버깅 작업이 빨라지며 장기적 프로그램 유지보수가 용이해진다.



#### 일반적 예외 처리를 사용하면 안 되나?

* 단언문은 런타임 에러를 처리하기 위한 메커니즘이 아닌, 디버깅을 돕는 것이다.
* 즉, 코드 속의 버그를 찾을 수 있게 하는 것이다. 프로그램 버그가 없다면 단언문 에러도 발생하지 않는다.



#### 단언문 문법

* ```python
  assert_stmt ::= "assert" expression1 ["," expression2]
  # expression1 : 테스트할 조건
  # expression2 : 단언문이 실패할 시 표시되는 에러 메시지.
  ```



#### 단언문의 함정

* 첫 번째로는 보안 위험과 버그에 대한 것이다.
* 두 번째는 쓸모없는 단언문을 작성하는 버릇이다.



#### 주의사항 1. 데이터 유효성 검증에 단언문을 사용하지 말자

* 단언문에서 관리자 권한등을 확인하는 것은 굉장히 위험하다.
  * 파이썬 인터프리터에서 단언문을 비활성화할 수 있는데, 만약 그렇다면 확인 코드가 발생하지 않으므로, 권한이 없어도 행동이 가능해진다.
  * 이처럼 특정 검사 기능이 작동하지 않는다면 심각한 공격을 받을 수 있다.



#### 주의사항 2. 절대 실패하지 않는 단언문

* assert문에서 첫 번째 인자로 튜플을 전달하면 그 단언문은 항상 참이 되므로 결코 실패하지 않는다. 이는 비어 있지 않은 튜플은 파이썬에서 항상 참인 것과 관련있다.



#### 파이썬 단언문

* 이런 위험한 면이 있지만 파이썬의 단언문은 강력한 디버깅 도구이다.
* 단언문에 대해 제대로 이해하면 디버깅과 유지 보수가 쉬운 파이썬 프로그램을 작성할 수 있다.



#### 요점 정리

* 파이썬의 단언문은 프로그램 내부 자체 검사로 조건을 테스트하는 디버깅 도구다.
* 단언문은 개발자가 버그를 식별하는 데 도움이 되지만, 런타임 에러를 처리하기 위한 매커니즘은 아니다.
* 인터프리터 설정으로 단언문을 전역적으로 비활성화할 수 있다.



<hr/>



## 2.2 보기 좋은 쉼표 배치



* git을 사용할 때, 변경 사항을 제대로 보기 위해서는 리스트나 딕셔너리, 세트 상수에서 모든 행을 상수로 끝내고 여러 행으로 작성하는 것이 좋다.

* ```python
  fruits = [
      'apple',
      'banana',
      'carrot',	# , 을 붙여도 에러는 나타나지 않는다!
  ]
  ```



<hr/>



## 2.3 콘텍스트 매니저와  with 문



* 파이썬의 with 문은 깨끗하고 가독성 좋은 코드를 작성할 수 있다.

* 기능을 추상화하고 재사용할 수 있게 하여 리소스 관리 패턴을 단순화한다.

* with 문을 사용하면 시스템 리소스를 처리하는 대부분의 로직을 추상화 할 수 있다.

* 명시적인 `try...finally`문을 사용하지 않고 with 문 만으로 처리할 수 있다.

* 즉, 리소스를 정리하거나 해제하는 일을 자동으로 처리하므로 버그나 메모리 누수를 피할 수 있다.

* ```python
  with open('hello.txt', 'w') as f:
      f.write('hello, world!')
  
  # 사실 둘은 같은 행동이지만, 위의 방법이 리소스를 자동으로 처리하므로 try...finally를 사용하지 않아도 되므로 버그를 피할 수 있다.
      
  f = ioen('hello.txt', w)
  try:
      f.write('hello, world')
  finally:
      f.close()
  ```



#### 객체에서 with 사용

* 콘텍스트 매니저를 사용하면 클래스와 함수에도 동일한 기능을 제공할 수 있다.
* 콘텍스트 매니저란 with 문을 지원하기 위해 객체가 따라야 하는 간단한 인터페이스이다. 
* 기본적으로 사용하려는 객체에 `__enter__`와 `__exit__` 메서드만 추가하면 된다. 그러면 파이썬이 리소스 관리 주기의 적절한 시기에 두 메서드를 호출한다.
* with 문의 콘텍스트로 들어갈 대 `__enter__`를 호출하고 그때 리소스를 확보한다. 그리고 실행이 콘텍스트를 벗어날 때 `__exit__`를 호출하여 리소스를 반환한다.



#### 요점 정리

* with 문은 표준적 `try/finally` 문 사용을 단순하게 한다.
* with 문은 주로 시스템 리소스의 안전학 획득 및 해제를 관리한다.

* with 문을 효과적으로 사용하면 리소스사 새는 것을 방지하고 코드를 일기 쉽게 만들 수 있다.



<hr/>



## 2.4 밑줄 문자와 던더



* 단일 밑줄 접두사: _var
* 단일 밑줄 접미사: var_
* 이중 밑줄 접두사: __var
* 이중 밑줄 접두사와 접미사: \__var\_\_
* 단독 밑줄 문자: _



#### 1. 단일 밑줄 접두사: '_var'

* 변수와 메서드 이름에서 단일 밑줄 접두사는 오로지 관례적 의미만 지닌다. 
* 단일 밑줄 접두사는 해당 변수 또는 메서드가 내부용으로만 쓰일 것이라는 의도를 알리기 위한 힌트다.
* 자바와 달리 프라이빗과 퍼블릭 변수 사이에 강력한 구분은 없으며, 접근하는 것 조차 막지 않는다. 단지 힌트를 줄 뿐이다.



#### 2. 단일 밑줄 접미사: 'var_'

* 변수에 가장 접합한 이름이 이미 파이썬 언어의 키워드로 사용되는 경우, 밑줄 접미사를 추가하여 충돌을 제거할 수 있다.



#### 3. 이중 밑줄 접두사: '__var'

* 이중 밑줄 접두사가 변수 앞에 붙었을 경우에는, 네임 맹글링(name mangling) 이라는 것이 작동한다. 
* 인터프리터가 클래스가 나중에 확장될 때 충돌이 발생하기 어렵게 변수를 바꾸는 방식이다.
* 예를 들어, Test 클래스의 `self.__baz`는 `_Test__baz`로 변경된다. 
* 네임 맹글링은 메서드 이름에도 적용이 된다. 
* 던더란 double underscore (이중 밑줄 문자)를 줄여 쓴 것이다. 



#### 4. 이중 밑줄 접두사와 접미사 '__var\_\_'

* 이 경우에는 네임 맹글링이 적용되지 않는다. 
* 이런 이름은 특수 용도로 예약되어 있다. 
* 이런 이름은 충돌이 날 수 있기 때문에 사용하지 않는 것이 바람직하다.



#### 5. 단독 밑줄 문자: '_'

* 관례적으로 중요하지 않음을 나타내기 위해 밑줄 문자 하나로 이름을 짓기도 한다.

* ```python
  for _ in range(10):
      print('CutyApple')
  ```

* 아니면 튜플을 언패킹 하는데, 몇 가지 정보가 필요 없는 경우에도 사용할 수 있다.

* ```python
  car = ('red', 12, 2020)
  color, _, _ = car
  print(_) # 2020
  ```

* 또한, 인터프리터가 구한 마지막 표현식의 결괏값을 나타내는 특수 변수로 사용된다.



<hr/>



## 2.5 문자열 형식화에 대한 충격적인 사실



#### #1. '구식' 문자열 형식화

* % 연산자를 이용하여 마치 C언어의 `printf` 처럼 동작한다.

* ```python
  'Hello, %s. My name is %s' % (name, myName)
  ```



#### #2. '신식' 문자열 형식화

* format() 함수를 이용하여 간단히 위치 지정을 할 수 있게 되었다.

* ```python
  'Hello, {name}. My name is {myName}'.format(name=name, myName=myName)
  ```



#### #3. '리터럴' 문자열 삽입 (3.6 이상)

* ```python
  f'Hello, {name}. My name is {myName}'
  ```



#### #4. 템플릿 문자열 

* string 모듈에서 Template 클래스를 가져와서 사용해야 한다.

* 템플릿 문자열은 변수를 지정해 두고, 후에 그 변수 값을 지정하여 사용하는 방식을 사용한다.

* ```python
  from string import Template
  t = Template('Hello, $name. My name is $myName')
  t.substitute(name=name, myName=myName)
  ```



#### 어떤 문자열 형식화를 사용해야 하는가?

* 3.6 이상을 사용하는 경우, 리터럴 문자열 삽입을 사용하고, 아니라면 신식 문자열 형식화를 사용하는 것이 좋다. 