



## 4장 클래스와 객체 지향 프로그래밍



### 4.1 객체 비교: 'is' 대 '=='



* == 연산자는 동등 여부를 검사하여 비교한다. 즉, 두 변수가 값이 같은지 알 수 있다.
* is 연산자는 동일 여부를 비교한다. 즉, 두 변수가 동일한 객체를 가리키고 있는지를 알 수 있다.



### 4.2 문자열 변환(모든 클래스는 _\_repr__이 필요하다)



* 파이썬에서 클래스의 인스턴스를 출력해 보면 만족스럽지 않은 결과가 나온다.
* 문자열로 전환하는 동작이 기초적이고 세부 내용이 부족하기 때문이다.
* 기본적으로 얻을 수 있는 정보는 클래스명과 객체 인스턴스의 id를 포함하는 문자열이다. 
* 클래스의 속성을 직접 출력하거나 클래스에 사용자 정의 메서드를 추가하여 이 문제를 해결하려고 할 수 있다.
* 그러나 자신만의 시스템을 만드는 대신 `__str__`과 `__repr__`던더 메서드를 추가하는 것이 좋다. 



#### _\_str__ 대 _\_repr__

* _\_str__ 던더 메서드는  인터프리터 세션에서 값을 제대로 출력하지 않는다.
* _\_repr__ 던더 메서드는 이런 기능을 제대로 수행한다. 또한, 이는 개발자의 디버깅을 도와주려는 의도가 더 강하다.



#### 모든 클래스에 _\_repr__이 필요한 이유

* _\_str__ 메서드를 추가하지 않으면 파이썬은 \_\_str__을 사용할 때도 \_\_repr\_\_ 을 사용한다. 이는 모든 경우에 유용한 문자 결과가 보장된다. 

* ```python
  def __repr(self):
      retrun f'Car({self.color!r}, {self.mileage)!r})'
  ```

* !r 변환 플래그를 사용하며 출력 문자열이 `str(self.color)`와 `str(self.mileage)` 대신 `repr(self.color)`와 `repr(self.mileage)`를 사용했다. 



<hr/>



### 4.3 자신만의 예외 클래스 정의하기

* 사용자 정의 에러 타입은 에러 사례를 분명히 드라나게 한다.

* 또한, 디버깅 정보를 제공하므로 유지 보수에 이점이 생긴다.

* ```python
  def validate(name):
      if len(name) < 10:
          raise ValueError
  ```

* 이런 식의 상위 수준 예외 클래스를 사용하는 데에는 단점이 있다.

* 만일 내부를 알지 못한 팀원이 이를 호출하여 에러가 난다고 하자.

* ```python
  Traceback (most recent call last):
    File "", line 5, in <module>
      validate('joe')
    File "", line 3, in validate
      raise ValueError
  ValueError
  ```

* 이 경우, 스택 추적은 그다지 도움이 되지 않는다. 이러한 코드는 비용이 늘어날 뿐이다 .

* 이러한 유효성 검사에 실패했음을 나타내는 사용자 정의 예외 타입이 있다.

* 이러한 사용자 정의 예외 클래스는 파이썬의 기본 예외에 기반을 두고 있지만, 더 명백한 이름을 부여함으로써 이름으로 어떤 오류가 났는지 알 수 있게 한다.

  ```python
  class NameTooShortError(ValueError):
      pass
  
  def validate(name):
      if len(name) < 10:
          raise NameTooShortError(name)
  ```

* ValueError 클래스를 확장한 NameTooShortError 예외타입을 가지게 되었다. 

* ```python
  Traceback (most recent call last):
    File "C:/Users/CutyApple/Desktop/Study/파이썬/ex.py", line 8, in <module>
      validate('joe')
    File "C:/Users/CutyApple/Desktop/Study/파이썬/ex.py", line 6, in validate
      raise NameTooShortError(name)
  __main__.NameTooShortError: joe
  ```

* 팀원의 입장에서는 어떤 잘못이 있는지 확실히 알 수 있을 것이다. 

* 일반적으로는 최상위 예외 계층을 하나 선언하여 다른 모든 사용자 예외의 상위 상속 에러가 되게 한다.



<hr/>



### 4.4 재미있고 이득이 되는 객체 복제하기

* 파이썬의 할당문은 객체의 사본을 만들지 않으며 이름만 연결한다. 변경할 수 없는 객체의 경우 일반적으로 차이가 없다. 
* 리스트, 딕셔너리, 세트 같은 변경 가능한 내장 컬렉션은 기존 컬렉션을 팩터리 함수에 건네 복사할 수 있다.
* 이런 메서드는 사용자 정의 객체는 처리하지 못하며, 얕은 복사본을 만든다.
* 얕은 복사본은 새 컬렉션 객체를 생성한 다음 원래 객체에서 찾은 자식 객체에 대한 참조로 채우는 것을 의미한다.
* 깊은 복사본은 복사 프로세스를 재귀적으로 처리한다. 새 컬렉션 객체르르 생성한 다음, 원래 객체에서 찾은 자식 객체의 복사본을 재귀적으로 채우는 것을 의미한다. 



#### 얕은 복사본 만들기

* ```python
  xs = [[1,2,3], [4,5,6], [7, 8,9]]
  ys = list(xs)
  xs.append('new')
  xs # [[1,2,3], [4,5,6], [7, 8,9], ['new']]
  ys # [[1,2,3], [4,5,6], [7, 8,9]]
  xs[1][0] = 'X'
  xs # [[1,2,3], ['X',5,6], [7, 8,9], ['new']]
  ys # [[1,2,3], ['X',5,6], [7, 8,9]]
  ```

* 얕은 복사본을 만들어서 ys에는 여전히 xs에 저장된 원본 자식 객체에 대한 참조가 포함되어 있다. 

* xs만 변경한 것 같지만, xs와 ys는 얕은 복사본으로 만들어서 자식 객체를 공유하기 때문에 같아진다.



#### 깊은 복사본 만들기

* 깊은 복사본은 copy 모듈의 deepcopy() 함수를 이용하여 만든다.
* 깊은 복사본은 원본과 복사본 모두가 완전히 독립적이다.



#### 임의의 객체 복사하기

* ```python
  class Point:
      def __intit__(self, x, y,):
          self.x = x
          self.y = y
          
      def __repr__(self):
          return f'Point({self.x!r}, {self.y!r})
  ```

* Point 인스턴스를 생성하여 copy 모듈을 이용하여 복사한다. 

* 이 둘을 is로 검사하면 false가 나오게 된다. 



* 객체의 얕은 복사본을 만들면 자식 객체가 복제되지 않는다.  따라서 사본은 원본과 완전히 독립적이다.
* 깊은 복사는 객체의 자식 객체를 재귀적으로 복사한다. 이렇게 얻은 복사본은 원본과 완전히 독립적이지만 깊은 복사에는 그만큼 시간이 더 걸린다. 
* copy 모듈을 사용하여 임의의 객체를 복사할 수 있다. 



<hr/>



### 4.5 추상화 클래스는 상속을 확인하다.



* 추상화 클래스 (Abstract Base Class, ABC)는 파생 클래스가 기반 클래스의 특정 메서드를 구현함을 보장한다. 
* 추상화 클래스를 사용하면 버그를 방지하고, 클래스 계층을 쉽게 유지 관리 할 수 있다. 
* 추상화 클래스는 파생 클래스가 인스턴스화될 때 기반 클래스의 추상 메서드를 모두 구현하는지 확인한다. 



<hr/>



### 4.6 네임드튜플은 어디에 적합한가



* 파이썬에는 네임드튜플(namedtuple) 컨테이너 타입이 잇다. 
* 네임드튜플은 클래스를 수동으로 정의하는 데 대한 훌륭한 대안이 될 수 있으며 여러 기능이 있다. 

* 튜플은 임의의 객체를 그룹화하기 위한 간단한 데이터 구조이다. 또한 불변성이 있기 때문에 생성후에는 수정할 수 없다.
* 튜플은 데이터를 가져오려면 반드시 정수 인덱스를 통해 가져와야 한다. 즉, 개별 속성에 이름을 지정할 수 없다.
* 또한, 튜플은 항상 임시 구조이다. 두 개의 튜플에 같은 수의 필드와 같은 속성이 담겨있다고 보장하기 어렵다.



#### 해결사 네임드튜플

* 네임드 튜플은 위의 두 문제를 해결한다.

* 네임드 튜플은 한 번만 쓰고 여러 번 읽는다는 원칙을 따른다.

* 고유한 식별자를 통해 각 객체에 접근할 수 있다. 

* ```python
  from collections import namedtuple
  Car = namedtuple('Car', 'color mileage size')
  my_car = Car('red', 3812.4, 'big')
  ```

* namedtuple을 import 해 준다.

* namedtiple 함수에 첫 인자는 namedtuple의 이름을 나타내고, 두 번째 인자는 필드들의 이름을 인코딩하여 전달한다. 내부에서는 split()을 이용하여 나누므로, 두 번째 인자에 직접 리스트로 전달할 수도 있다.



#### 네임드튜플 상속하기

* 네임드튜플은 일반 파이썬 클래스 위에서 만들어지기 때문에 네임드튜플 객체에 메서드를 추가할 수 있다. 
* 네임드튜플의 내부적 구성 방식 때문에 불변 필드를 추가하기 까다롭다 .
* 이때는 _fields 속성을 이용하여 필드를 추가할 수 있다.



#### 내장 도우미 메서드

* 네임드튜플 인스턴스는 몇 가지 도우미 메서드들을 제공한다. 
* 이 메서드들은 _접두사를 쓰는데, 이때의 의미는 프라이빗을 의미하지 않는다.
* `_asdict` : 네임드튜플을 딕셔너리로 수정한다.
* `_replace` : 튜플의 얕은 복사본을 생성하고 필드의 일부를 선택적으로 대체한다.
* `_make` : 객체 시퀀스나 반복 가능 객체로부터 새로운 네임드튜플 인스턴스를 생성할 수 있다.



#### 네임드튜플을 사용하면 좋은 경우

* 네임드튜플은 데이터를 구조화하고,코드를 정돈하며, 가독성을 향상시킨다.



<hr/>



### 4.7 클래스 변수 대 인스턴스 변수의 함정



* 파이썬 객체 모델은 클래스와 인스턴스의 변수도 구별한다.
* **클래스 변수**
  * 클래스 정의 안에(인스턴스 메서드 밖에) 선언된다. 
  * 이 변수는 특정 클래스 인스턴스에 묶여 있는 것이 아닌, 클래스 자체에 내용을 저장하고 같은 클래스에서 생성된 모든 객체는 동일한 클래스 변수 집합을 공유한다.
  * 예를 들어 클래스 변수를 수정하면 모든 객체 인스턴스에 영향이 간다는 것이다.
* **인스턴스 변수**
  * 항상 특정 객체 인스턴스에  묶여 있다.
  * 그 내용은 클래스에 저장되지 않고 클래스에서 생성된 개별 객체에 저장된다. 따라서 인스턴스 변수의 내용은 객체마다 독립적이므로 변수의 값을 수정하면 해당 객체에만 영향을 미친다.
* 인스턴스 변수는 각 객체 인스턴스에 특정되고 \__init__ 생성자가 실행될 때 만들어진다. 클래스 자체에는 존재하지 않는다.
* 클래스 변수는 동일한 이름의 인스턴스 변수에 의해 가려질 수 있기 때문에 덮어써서 버그나 이상한 동작을 유발하기 쉽다.



<hr/>



### 4.8 인스턴스 메서드, 클래스 메서드, 정적 메서드의 신비를 풀다



* ```python
  class MyClass:
      def method(self):
          return 'instance method called', self
  
      @classmethod
      def classmethod(cls):
          return 'class method called', cls
  
      @staticmethod
      def staticmethod():
          return 'static method called'
  ```

* **인스턴스 메서드**

  * method는 일반 인스턴스 메서드이다. 
  * 이 메서드는 self라는 단 하나의 매개 변수를 받는데, 이 변수는 method가 호출될 대의 MyClass를 가리킨다. 
  * 물론 인스턴스 메서드는 하나 이상의 매개 변수를 받아들일 수 있다.
  * self 매개 변수를 통해 인스턴스 메서드는 동일한 객체에 정의된 속성 미 다른 메서드에 자유롭게 접근할 수 있다.
  * 이는 객체의 상태를 수정할 수 있도록 해 주는 강력한 기능이다.

* **클래스 메서드**

  * MyClass.classmethod는 클래스 메서드이다. 
  * 데코레이터는 해당 메서드가 클래스 메서드임을 표시하는 역할이다.
  * 객체 인스턴스를 가리키는 self 매개 변수 대신, 클래스 메서드는 클래스를 가리키는 cls매개 변수를 받는다.
  * 클래스 메서드는 이 cls 인자에만 접근할 수 있기 때문에 객체 인스턴스 상태를 수정할 수 없다.

* **정적 메서드**

  * MyClass.staticmethod는 정적 메서드이다.
  * 이 메서드는 @staticmethod 데코레이터를 달아 정적 메서드로 지정되엇다.
  * 정적 메서드도 임의 개수의 매개 변수를 받아들일 수 있지만, self나 cls 매개 변수는 사용하지 않는다.