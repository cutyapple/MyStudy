## 3장 효과적인 함수



### 3.1 파이썬 함수는 일급 객체다

* 파이썬의 함수는 일급 객체(first-class object)다. 
* 변수에 할당하고 데이터 구조에 저장하고 인자로 전달하고 반환할 수도 있다.



#### 함수는 객체다

* ```python
  def yell(text):
      return text.upper() + '!'
  ```



* 파이썬 프로그램의 모든 데이터는 객체 또는 객체 간의 관계로 표현된다.
* 함수도 마찬가지로 객체이기 때문에  다른 변수에 할당할 수 있다.

* ```python
  bark = yell
  ```



* 이 라인은 함수를 호출하지 않는다. 단지 yell이 참조하는 함수 객체를 취하여 그것을 가리키는 두 번재 이름인 bark를 만든다. 

* bark를 호출하여 동일한 함수 객체를 실행할 수 있다.

* 함수 객체와 함수 이름은 별개이다. 함수의 원래 이름을 삭제하고 다른 이름으로 여전히 동일한 로직의 함수를 실행시킬 수 있기 때문이다.

* ```python
  dell yell
  bark('hey')
  ```

* 파이썬은 디버깅을 위해 모든 함수를 생성할 때 문자열 식별자를 붙인다. `__name__`속성을 이용하여 이 내부 식별자에 접근할 수 있다.



#### 함수는 데이터 구조에 저장할 수 있다.

* 함수는 일급 객체이므로 다른 객체와 마찬가지로 함수를 데이터 구조에 저장할 수 있다.
* 이에 저장된 함수 객체에 접근하는 방법 역시 다른 타입의 객체에 접근하는 방법과 같다.



#### 함수는 다른 함수로 전달할 수 있다.

* 함수는 객체이므로 인자로 전달할 수 있다.

* ```python
  def greet(func):
      greeting = func('Hi, I am a Python program')
      print(greeting)
      
  greet(bark)
  ```

* 함수 객체를 다른 함수에 인자로 전달하는 기능은 강력하다. 함수가 수행하는 동작을 추상화해서 전달할 수 있기 때문이다. 

* 다른 함수를 인자로 받을 수 있는 함수를 고차 함수(higher-order function)이라고도 하며 함수형 프로그래밍 스타일에서 필요하다.



#### 함수는 중첩될 수 있다.

* 파이썬은 함수 안에서 다른 함수를 정의할 수 있다. 이를 중첩 함수 또는 내부 함수라고 한다.

* ```python
  def speak(text):
      def whisper(t):
          return t.lower() + '...'
      return whisper(text)
  ```

* speak 함수가 불릴 때마다 새로운 내부함수 whisper를 정의한 다음 즉시 호출한다.

* 그런데 whisper 함수는 speak 바깥에서는 존재하지 않는 함수이다.

* 함수는 객체이므로 내부 함수를 부모 함수의 호출자에 반환할 수 있다.

* 함수는 인자를 통해 동작을 전달할 뿐 아니라 동작을 반환할 수도 있다.



#### 함수는 지역 상태를 포착할 수 있다.

* 내부 함수는 매개 변수가 없지만 부모 함수에서 정의된 매개 변수에 계속 접근할 수 있다. 마치 인자의 값을 기억하는 것처럼.

* 이런 동작의 함수를 렉시컬 클로저 또는 클로저라고 한다. 

* 클로저는 프로그램 흐름이 더 이상 해당 범위에 있지 않은 경우에도 둘러싼 어휘 범위 안의 값들을 기억한다.

* ```python
  def make_adder(n):
      def add(x):
          return x + n
      return add
  plus_3 = make_adder(3)
  plus_3(4) # 7   n이 분명 매개변수에는 없지만 클로저에 의하여 n(3)을 기억하게 된다. 그리고 후에 들어온 x(4)를 수행한다.
  ```



#### 객체는 함수처럼 동작할 수 있다.

* 함수는 객체처럼 동작할 수 있지만, 반대는 아니다. 
* 그러나 객체를 호출 가능하게 만들 수 있다.
* 객체가 호출 가능하다는 뜻은 둥근 괄호 형식의 함수 호출 문법을 사용하고 인자를 전달할 수 있음을 의미한다.
* 이 기능은 모두 `__call__` 던더 메서드로 구성된다. 
* 객체를 함수처럼 호출하면 그 내부에서는 해당 객체의 `__call__` 메서드가 실행된다. 
* 모든 객체가 호출이 가능한 것은 아니다. 그래서 객체가 호출 가능한지 확인해주는 callable 내장 함수가 준비되어 있다.



### 3.2 람다는 단일 표현식 함수다.



* lambda 키워드는 작은 익명 함수를 선언하는 방법이다.

* 람다 함수는 def 키워드로 선언된 일반 함수처럼 작동하며 함수 객체가 필요할 때마다 사용할 수 있다. 

* ```python
  add = lambda x, y : x + y
  print(add(1, 2)) # 3
  ```

* 람다는 def를 사용하여 함수를 선언하는 것과 동일하지만 인라인으로 작성됐다. 

* 주요 차이점은 함수 객체를 사용 하기 없어 함수 객체를 이름에 바인딩할 필요가 없다는 것이다. 간단히 말해 람다의 일부로 계산하고자 하는 표현을 말한 다음, 람다를 일반 함수처럼 호출하여 즉시 평가한다. 

* 또 다른 차이점으로는 람다에는 명령문이나 주석, 리턴문을 사용할 수 없다. 

* 람다에서는 암시적 반환 구문이 있는 셈으로, 그래서 람다를 단일 표현식 함수라고 부르기도 한다.



#### 람다를 사용할 수 있는 경우

* 람다는 정의하는데 편리하고 비격식적 지름길을 제공한다.
* 가장 흔한 람다 사용 예제는 리스트를 정럴하기 위한 짧고 간결한 key 함수를 작성하는 것이다. 
* 람다에는 일반적 중첩 함수처럼 렉시컬 클로저로도 동작한다.



#### 람다 함수를 자제해야 하는 경우

* 너무 복잡한 함수로 정의하면 가독성이 떨어질 수 있다.
* 간단한 상황을 굳이 람다로 정의하면 효율이 떨어질 수 있다.



<hr/>



### 3.3 데코레이터의 힘



* 파이썬의 코어에서 데코레이터는 호출 가능 객체를 동작을 확장, 수정할 수 있게 한다.
* 이러한 기능에는 데코레이터가 유용하다. 
* 로그 남기기, 접근 제어와 인증 시행, 계측 및 시간 측정, 비율 제한, 캐싱 및 기타



#### 파이썬 데코레이터 기초

* 데코레이터는 다른 함수를 장식하거나 포장하고, 감싼 함수가 실행되기 전과 후에 다른 코드를 실행할 수 있게 한다.

* ```python
  def null_decorator(func):
      return func
  
  @null_decorator
  def greet():
  	return 'Hello!' 
  
  greet()
  ```

* `@null_decorator` 행을 함수 정의 앞에 두는 것은 함수를 먼저 정의한 다음 데코레이터를 거치는 것과 같다. 

* @ 구문을 사용하면 정의 시간에 즉시 함수가 장식된다. 



#### 데코레이터는 동작을 수정할 수 있다

* ```python
  def uppercase(func):
      def wrapper():
          ori_res = func()
          mod_res = ori_res.upper()
          return mod_res
      return wrapper
  ```

* wrapper 클로저는 장식되지 않은 입력 함수에 접근할 수 있으며 입력 함수를 호출하기 전후에 추가 코드를 자유롭게 실행할 수 있다.

* uppercase 데코레이터는 함수 자체다. 그리고 그것이 장식하는 입력 함수의 '미래 행동'에 영향을 주는 유일한 방법은 입력 함수를 클로저로 감싸는 것이다.

* 이것이 uppercase 데코레이터가 나중에 호출되어 원래의 입력 함수를 실행하고 그 결과를 수정할 수 있는 다른 함수(클로저)를 정의하고 반환하는 이유다. 

* 데코레이터는 감싼 클로저를 통해 호출 가능 객체의 동작을 수정하므로 원본을 영구적으로 수정할 필요가 없다. 원래의 호출 가능 객체는 전혀 수정되지 않으며 장식될 때만 동작이 변경된다. 



#### 다중 데코레이터를 함수에 적용하기

* ```python
  def strong(func):
      def wrapper():
          return '<strong>' + func() + '</strong>'
      return wrapper
  
  def emp(func):
      def wrapper():
          return '<emp>' + func() + '</emp>'
      return wrapper
  
  @strong
  @emp
  def greet():
      return 'Hello!'
  
  print(greet())
  
  # <strong><emp>Hello!</emp></strong>
  ```

* 다중 데코레이터를 사용할 시, 아래부터 위 순서로 적용이 된 것을 알 수 있다. 

* 이를 데코레이터 쌓기 라고도 한다. 이를 데코레이터를 사용하지 않고 나타낸다면 다음과 같을 것이다.

* ```python
  deco_greet = strong(emp(greet))
  ```

* 즉, 아래에서부터 greet -> emp -> strong 순으로 올라간다. 



#### 인자를 받는 함수 장식하기

* 변수의 개수가 가변적일때는 `*args`와 `*kwargs`를 이용해야 한다.

* ```python
  def proxy(func):
      def wrapper(*args, **kwargs):
          return func(*args, **kwargs)
      return wrapper
  ```

* wrapper 클로저 정의에서 * 및 **연산자를 사용하여 모든 위치 및 키워드 인자를 수집하고 변수에 저장한다.

* wrapper 클로저는 수집된 인자를 * 및 ** 인자 풀기 연산자를 사용하여 원래 입력 함수로 전달한다. 



#### '디버깅 가능한' 데코레이터 작성법

* 데코레이터를 사용하면 실제로 한 함수가 다른 함수로 교체된다.
* 이 프로세스의 단점은 원래 함수에 첨부된 일부 메타데이터를 숨겨 버리는 것이다. 
* 함수명, 독스트링, 매개 변수 리스트는 감싼 클로저에 의해 숨겨진다.
* 이로 인해 파이썬 인터프리터로 디버깅하기가 불편하고 어려워진다. 
* 이 문제는 파이썬 표준 라이버리에 포함되어 있는 functools.wraps를 사용하여 사용하여 잃어버린 메타데이터를 장식되지 않은 할 수에서 데코레이터 클로저로 복사할 수 있다.



<hr/>



### 3.4 *args와 **kwargs를 재미있게 활용하기



* *args와 **kwargs 매개 변수는 함수가 선택적 인자를 받아들일 수 있게 하므로 모듈  및 클래스에 유연한 API를 만들 수 있다.

* ```python
  def foo(required, *args, **kwargs):
      print(required)
      if args:
          print(args)
      if kwargs:
          print(kwargs)
  ```

* required 라는 인자는 반드시 필요하지만, 추가 위치 인자와 키워드 매개 변수는 추가로 선택하여 사용할 수 있다. 

* 추가 인자를 사용하여 함수를 호출하면 매개 변수 이름 앞에 * 접두사가 있기 때문에 args가 여분의 위치 인자를 튜플로 수집한다.

* kwargs는 매개 변수명에 **접두사가 있기 대문에 딕셔너리로 추가 키워드 인자를 수집한다.



#### 선택적 또는 키워드 매개 변수 전달하기

* 한 함수에서 다른 함수로 선택적 또는 키워드 매개 변수를 전달할 수 있다.

* 인자를 전달할 함수를 호출할 때 인자 풀기 연산자 *와 **를 사용하면 된다. 

* 또한 인자를 전달하기 전, 인자를 수정할 수 있는 기회를 제공한다.

* ```python
  def foo(x, *args, **kwargs):
  	kwargs['name'] = 'Alice'
      new_args = args + ('extra', )
      bar(x, *new_args, **kwargs)
  ```

* 이 기술은 감싸는 함수를 작성하고 서브클래싱하는 데 유용하다. 

* 부모 클래스 생성자의 시그니처 전체를 자식 클래스에 복제하지 않고도 부모 클래스의 동작을 확장할 수 있다.



<hr/>



### 3.5 함수 인자 풀기

* ```python
  def print_vec(x, y, z):
      print('<%s, %s, %s' % (x, y, z))
  ```

* 이 함수는 세 개의 인자를 취해 출력한다.

* 튜플 또는 리스트로 인자를 둔 경우, 각 컴푸넌트의 색인을 명시적으로 지정해야 한다.

* 그러나 이러한 구성 요소를 * 연산자를 이용하여 함수 인자 풀기를 할 수 있다. 

* 반복 가능 객체 앞에 *를 두면 인자를 풀어서 각가의 요소를 풀어서 개별 인자로 보낸다. 

* 딕셔너리에서 사용할 수 있는 ** 연산자도 있다.

* ```python
  dict_vec = {'y':0, 'z':1. 'x':1}
  print_vec(**dict_vec)
  #y, x, z
  ```

* 딕셔너리는 순서가 지정되지 않으므로 딕셔너리의 키를 기준으로 이름이 같은 인자와 해당 딕셔너리 값을 연결한다. 



<hr/>



### 3.6 반환할 것이 없는 경우



* 파이썬은 함수의 끝에 암시적으로 `return None` 문을 추가한다. 따라서 함수가 반호나값을 지정하지 않으면, 기본적으로 `None`이 반환된다.