## 3장 효과적인 함수



### 3.1 파이썬 함수는 일급 객체다

* 파이썬의 함수는 일급 객체(first-class object)다. 
* 변수에 할당하고 데이터 구조에 저장하고 인자로 전달하고 반환할 수도 있다.



#### 함수는 객체다

* ```python
  def yell(text):
      return text.upper() + '!'
  ```



* 파이썬 프로그램의 모든 데이터는 객체 또는 객체 간의 관계로 표현된다.
* 함수도 마찬가지로 객체이기 때문에  다른 변수에 할당할 수 있다.

* ```python
  bark = yell
  ```



* 이 라인은 함수를 호출하지 않는다. 단지 yell이 참조하는 함수 객체를 취하여 그것을 가리키는 두 번재 이름인 bark를 만든다. 

* bark를 호출하여 동일한 함수 객체를 실행할 수 있다.

* 함수 객체와 함수 이름은 별개이다. 함수의 원래 이름을 삭제하고 다른 이름으로 여전히 동일한 로직의 함수를 실행시킬 수 있기 때문이다.

* ```python
  dell yell
  bark('hey')
  ```

* 파이썬은 디버깅을 위해 모든 함수를 생성할 때 문자열 식별자를 붙인다. `__name__`속성을 이용하여 이 내부 식별자에 접근할 수 있다.



#### 함수는 데이터 구조에 저장할 수 있다.

* 함수는 일급 객체이므로 다른 객체와 마찬가지로 함수를 데이터 구조에 저장할 수 있다.
* 이에 저장된 함수 객체에 접근하는 방법 역시 다른 타입의 객체에 접근하는 방법과 같다.



#### 함수는 다른 함수로 전달할 수 있다.

* 함수는 객체이므로 인자로 전달할 수 있다.

* ```python
  def greet(func):
      greeting = func('Hi, I am a Python program')
      print(greeting)
      
  greet(bark)
  ```

* 함수 객체를 다른 함수에 인자로 전달하는 기능은 강력하다. 함수가 수행하는 동작을 추상화해서 전달할 수 있기 때문이다. 

* 다른 함수를 인자로 받을 수 있는 함수를 고차 함수(higher-order function)이라고도 하며 함수형 프로그래밍 스타일에서 필요하다.



#### 함수는 중첩될 수 있다.

* 파이썬은 함수 안에서 다른 함수를 정의할 수 있다. 이를 중첩 함수 또는 내부 함수라고 한다.

* ```python
  def speak(text):
      def whisper(t):
          return t.lower() + '...'
      return whisper(text)
  ```

* speak 함수가 불릴 때마다 새로운 내부함수 whisper를 정의한 다음 즉시 호출한다.

* 그런데 whisper 함수는 speak 바깥에서는 존재하지 않는 함수이다.

* 함수는 객체이므로 내부 함수를 부모 함수의 호출자에 반환할 수 있다.

* 함수는 인자를 통해 동작을 전달할 뿐 아니라 동작을 반환할 수도 있다.



#### 함수는 지역 상태를 포착할 수 있다.

* 내부 함수는 매개 변수가 없지만 부모 함수에서 정의된 매개 변수에 계속 접근할 수 있다. 마치 인자의 값을 기억하는 것처럼.

* 이런 동작의 함수를 렉시컬 클로저 또는 클로저라고 한다. 

* 클로저는 프로그램 흐름이 더 이상 해당 범위에 있지 않은 경우에도 둘러싼 어휘 범위 안의 값들을 기억한다.

* ```python
  def make_adder(n):
      def add(x):
          return x + n
      return add
  plus_3 = make_adder(3)
  plus_3(4) # 7   n이 분명 매개변수에는 없지만 클로저에 의하여 n(3)을 기억하게 된다. 그리고 후에 들어온 x(4)를 수행한다.
  ```



#### 객체는 함수처럼 동작할 수 있다.

* 함수는 객체처럼 동작할 수 있지만, 반대는 아니다. 
* 그러나 객체를 호출 가능하게 만들 수 있다.
* 객체가 호출 가능하다는 뜻은 둥근 괄호 형식의 함수 호출 문법을 사용하고 인자를 전달할 수 있음을 의미한다.
* 이 기능은 모두 `__call__` 던더 메서드로 구성된다. 
* 객체를 함수처럼 호출하면 그 내부에서는 해당 객체의 `__call__` 메서드가 실행된다. 
* 모든 객체가 호출이 가능한 것은 아니다. 그래서 객체가 호출 가능한지 확인해주는 callable 내장 함수가 준비되어 있다.



### 3.2 람다는 단일 표현식 함수다.



* lambda 키워드는 작은 익명 함수를 선언하는 방법이다.

* 람다 함수는 def 키워드로 선언된 일반 함수처럼 작동하며 함수 객체가 필요할 때마다 사용할 수 있다. 

* ```python
  add = lambda x, y : x + y
  print(add(1, 2)) # 3
  ```

* 람다는 def를 사용하여 함수를 선언하는 것과 동일하지만 인라인으로 작성됐다. 

* 주요 차이점은 함수 객체를 사용 하기 없어 함수 객체를 이름에 바인딩할 필요가 없다는 것이다. 간단히 말해 람다의 일부로 계산하고자 하는 표현을 말한 다음, 람다를 일반 함수처럼 호출하여 즉시 평가한다. 

* 또 다른 차이점으로는 람다에는 명령문이나 주석, 리턴문을 사용할 수 없다. 

* 람다에서는 암시적 반환 구문이 있는 셈으로, 그래서 람다를 단일 표현식 함수라고 부르기도 한다.



#### 람다를 사용할 수 있는 경우

* 람다는 정의하는데 편리하고 비격식적 지름길을 제공한다.
* 가장 흔한 람다 사용 예제는 리스트를 정럴하기 위한 짧고 간결한 key 함수를 작성하는 것이다. 
* 람다에는 일반적 중첩 함수처럼 렉시컬 클로저로도 동작한다.



#### 람다 함수를 자제해야 하는 경우

* 너무 복잡한 함수로 정의하면 가독성이 떨어질 수 있다.
* 간단한 상황을 굳이 람다로 정의하면 효율이 떨어질 수 있다.



<hr/>



### 3.3 데코레이터의 힘



* 파이썬의 코어에서 데코레이터는 호출 가능 객체를 동작을 확장, 수정할 수 있게 한다.
* 이러한 기능에는 데코레이터가 유용하다. 
* 로그 남기기, 접근 제어와 인증 시행, 계측 및 시간 측정, 비율 제한, 캐싱 및 기타



#### 파이썬 데코레이터 기초

* 데코레이터는 다른 함수를 장식하거나 포장하고, 감싼 함수가 실행되기 전과 후에 다른 코드를 실행할 수 있게 한다.

* ```python
  def null_decorator(func):
      return func
  
  @null_decorator
  def greet():
  	return 'Hello!' 
  
  greet()
  ```

* `@null_decorator` 행을 함수 정의 앞에 두는 것은 함수를 먼저 정의한 다음 데코레이터를 거치는 것과 같다. 

* @ 구문을 사용하면 정의 시간에 즉시 함수가 장식된다. 



#### 데코레이터는 동작을 수정할 수 있다

* ```python
  def uppercase(func):
      def wrapper():
          ori_res = func()
          mod_res = ori_res.upper()
          return mod_res
      return wrapper
  ```

* wrapper 클로저는 장식되지 않은 입력 함수에 접근할 수 있으며 입력 함수를 호출하기 전후에 추가 코드를 자유롭게 실행할 수 있다.

* uppercase 데코레이터는 함수 자체다. 그리고 그것이 장식하는 입력 함수의 '미래 행동'에 영향을 주는 유일한 방법은 입력 함수를 클로저로 감싸는 것이다.

* 이것이 uppercase 데코레이터가 나중에 호출되어 원래의 입력 함수를 실행하고 그 결과를 수정할 수 있는 다른 함수(클로저)를 정의하고 반환하는 이유다. 

* 데코레이터는 감싼 클로저를 통해 호출 가능 객체의 동작을 수정하므로 원본을 영구적으로 수정할 필요가 없다. 원래의 호출 가능 객체는 전혀 수정되지 않으며 장식될 때만 동작이 변경된다. 

